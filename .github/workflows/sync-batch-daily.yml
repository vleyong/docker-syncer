name: 01. æ‰¹é‡åŒæ­¥ (Batch Sync)

on:
  push:
    paths:
      - "images.txt"
  schedule:
    - cron: "0 0 1,15 * *"
  workflow_dispatch:
    inputs:
      force_sync:
        description: "å¼ºåˆ¶åŒæ­¥ (è·³è¿‡æ‘˜è¦æ¯”å¯¹)"
        required: false
        type: boolean
        default: false

env:
  ALIYUN_REGISTRY: ${{ secrets.ALIYUN_REGISTRY }}
  ALIYUN_NAMESPACE: ${{ secrets.ALIYUN_NAMESPACE }}
  WEBHOOK_URL: ${{ secrets.WEBHOOK_URL }}
  # æ˜ å°„ Secret åˆ° Env ä»¥ä¾› if åˆ¤æ–­
  DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USERNAME }}

jobs:
  batch-sync:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    steps:
      - name: ğŸ—‘ï¸ æ¸…ç†ç£ç›˜ç©ºé—´
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: "true"
          remove-android: "true"
          remove-haskell: "true"
          remove-codeql: "true"
          build-mount-path: "/var/lib/docker/"

      - name: é‡å¯ Docker æœåŠ¡
        run: sudo service docker restart

      - name: æ£€æŸ¥ Secrets
        run: |
          if [ -z "${{ secrets.ALIYUN_USERNAME }}" ] || [ -z "${{ secrets.ALIYUN_PASSWORD }}" ]; then
            echo "âŒ é”™è¯¯: æœªé…ç½® ALIYUN_USERNAME æˆ– ALIYUN_PASSWORDSecretsã€‚"
            echo "è¯·åœ¨ Settings -> Secrets and variables -> Actions ä¸­é…ç½®ã€‚"
            exit 1
          fi

      - name: Checkout Code
        uses: actions/checkout@v3

      - name: ç™»å½•é˜¿é‡Œäº‘ ACR
        uses: docker/login-action@v2
        with:
          registry: ${{ env.ALIYUN_REGISTRY }}
          username: ${{ secrets.ALIYUN_USERNAME }}
          password: ${{ secrets.ALIYUN_PASSWORD }}

      - name: ç™»å½• DockerHub
        if: env.DOCKERHUB_USER != ''
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
        continue-on-error: true

      - name: ğŸ“¦ æ‰¹é‡å¤„ç†é•œåƒ
        run: |
          # å®šä¹‰é‡è¯•å‡½æ•°
          # å®šä¹‰é‡è¯•å‡½æ•°
          function retry {
            local n=1
            local max=3
            local delay=5
            while true; do
              "$@" && break || {
                if [[ $n -lt $max ]]; then
                  ((n++))
                  echo "âš ï¸ å‘½ä»¤å¤±è´¥ï¼Œå¿è¯•ç¬¬ $n/$max æ¬¡é‡è¯•..." >&2
                  sleep $delay;
                else
                  echo "âŒ å‘½ä»¤åœ¨ $max æ¬¡å°è¯•åå¤±è´¥ã€‚" >&2
                  return 1
                fi
              }
            done
          }

          if [ ! -f "images.txt" ]; then
            echo "âŒ images.txt ä¸å­˜åœ¨ã€‚"
            exit 0
          fi

          echo "ğŸ“‹ å¼€å§‹æ‰¹é‡å¤„ç†..."

          while IFS= read -r line || [ -n "$line" ]; do
            # å»é™¤é¦–å°¾ç©ºç™½
            line=$(echo "$line" | xargs)
            # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
            [[ -z "$line" || "$line" =~ ^# ]] && continue

            echo "----------------------------------------"
            echo "ğŸ”„ å¤„ç†æŒ‡ä»¤: $line"

            # 1. è§£æå‚æ•°
            PLATFORM_ARG=""
            SKOPEO_OS="linux"
            SKOPEO_ARCH="amd64"
            
            # ä½¿ç”¨æ›´å¥å£®çš„æ­£åˆ™åŒ¹é… platform
            if [[ "$line" =~ --platform[=\ ]([^ ]+) ]]; then
              PLATFORM_VAL="${BASH_REMATCH[1]}"
              PLATFORM_ARG="--platform $PLATFORM_VAL"
              echo "âš™ï¸  æŒ‡å®šæ¶æ„: $PLATFORM_VAL"
                 
              if [[ "$PLATFORM_VAL" == *"/"* ]]; then
                SKOPEO_OS=$(echo "$PLATFORM_VAL" | cut -d'/' -f1)
                SKOPEO_ARCH=$(echo "$PLATFORM_VAL" | cut -d'/' -f2)
              else
                SKOPEO_ARCH="$PLATFORM_VAL"
              fi
            fi
            
            SKOPEO_FLAGS="--override-os $SKOPEO_OS --override-arch $SKOPEO_ARCH"

            # æå–é•œåƒåï¼ˆç§»é™¤å‚æ•°éƒ¨åˆ†ï¼‰
            SRC_IMAGE=$(echo "$line" | awk '{print $NF}')
            
            # 2. å‘½åå¤„ç† (Smart Naming)
            # æå– Scope (namespace) å’Œ Basename
            # Logic: bitnami/redis -> Scope: bitnami, Base: redis
            #        redis -> Scope: "", Base: redis
            #        library/redis -> Scope: "", Base: redis
            
            SCOPE=""
            BASE_NAME=$(basename "$SRC_IMAGE" | cut -d':' -f1)
            TAG_NAME=$(echo "$SRC_IMAGE" | cut -d':' -f2 -s)
            [ -z "$TAG_NAME" ] && TAG_NAME="latest"
            
            # ç®€å•è§£æ namespace
            if [[ "$SRC_IMAGE" == *"/"* ]]; then
                NAMESPACE_PART=$(dirname "$SRC_IMAGE")
                if [[ "$NAMESPACE_PART" != "library" && "$NAMESPACE_PART" != "." ]]; then
                   SCOPE=$(basename "$NAMESPACE_PART")
                fi
            fi
            
            if [ -n "$SCOPE" ]; then
               TARGET_TAG="${SCOPE}_${BASE_NAME}:${TAG_NAME}"
            else
               TARGET_TAG="${BASE_NAME}:${TAG_NAME}"
            fi
            
            # å¤šæ¶æ„å‰ç¼€è¿½åŠ 
            if [ -n "$PLATFORM_VAL" ]; then
               PLATFORM_PREFIX=$(echo "$PLATFORM_VAL" | sed 's/\//_/g')
               TARGET_TAG="${PLATFORM_PREFIX}_${TARGET_TAG}"
            fi

            ALI_TARGET="$ALIYUN_REGISTRY/$ALIYUN_NAMESPACE/$TARGET_TAG"
            
            # 3. æ‘˜è¦æ¯”å¯¹
            FORCE="${{ inputs.force_sync }}"
            NEED_PULL=true

            if [ "$FORCE" != "true" ]; then
               echo "ğŸ” æ¯”å¯¹ Digest & Created ($SKOPEO_ARCH)..."
               
               # è·å–æºä¿¡æ¯: Digest|Created
               SRC_INFO=$(retry skopeo inspect $SKOPEO_FLAGS "docker://$SRC_IMAGE" --format='{{.Digest}}|{{.Created}}' 2>/dev/null || echo "")
               SRC_DIGEST=$(echo "$SRC_INFO" | cut -d'|' -f1)
               SRC_CREATED=$(echo "$SRC_INFO" | cut -d'|' -f2)
               
               DEST_INFO=$(retry skopeo inspect $SKOPEO_FLAGS "docker://$ALI_TARGET" --format='{{.Digest}}|{{.Created}}' 2>/dev/null || echo "")
               DEST_DIGEST=$(echo "$DEST_INFO" | cut -d'|' -f1)
               DEST_CREATED=$(echo "$DEST_INFO" | cut -d'|' -f2)

               if [ -n "$SRC_DIGEST" ]; then
                   if [ "$SRC_DIGEST" == "$DEST_DIGEST" ]; then
                       echo "âœ… é•œåƒæ‘˜è¦ä¸€è‡´ ($SRC_DIGEST)ï¼Œè·³è¿‡ã€‚"
                       NEED_PULL=false
                   elif [ -n "$DEST_DIGEST" ] && [ "$SRC_CREATED" == "$DEST_CREATED" ]; then
                       echo "âš ï¸ é•œåƒæ‘˜è¦ä¸åŒï¼Œä½†åˆ›å»ºæ—¶é—´ä¸€è‡´ ($SRC_CREATED)ï¼Œåˆ¤å®šä¸ºåŒæºï¼Œè·³è¿‡ã€‚"
                       NEED_PULL=false
                   else
                       echo "ğŸš€ é•œåƒæœ‰æ›´æ–° (Digest/Timeä¸åŒ¹é…)ï¼Œå‡†å¤‡åŒæ­¥ã€‚"
                       echo "   æº: $SRC_DIGEST ($SRC_CREATED)"
                       echo "   ç›®: $DEST_DIGEST ($DEST_CREATED)"
                   fi
               else
                   echo "âš ï¸ æ— æ³•è·å–æºé•œåƒä¿¡æ¯ï¼Œè·³è¿‡ã€‚"
                   NEED_PULL=false
               fi
            else
               echo "âš ï¸ å¼ºåˆ¶æ¨¡å¼ï¼Œè·³è¿‡æ¯”å¯¹ã€‚"
            fi

            # 4. æ‰§è¡ŒåŒæ­¥
            if [ "$NEED_PULL" == "true" ]; then
               echo "ğŸ“¥ æ‹‰å– $SRC_IMAGE ..."
               retry docker pull $SRC_IMAGE $PLATFORM_ARG
               
               echo "ğŸ·ï¸ æ‰“æ ‡ç­¾ -> $ALI_TARGET"
               docker tag "$SRC_IMAGE" "$ALI_TARGET"
               
               echo "ğŸ“¤ æ¨é€ $ALI_TARGET ..."
               retry docker push "$ALI_TARGET"
               
               echo "ğŸ§¹åœ¨æ­¤æ¸…ç† ..."
               docker rmi "$SRC_IMAGE" "$ALI_TARGET" >/dev/null 2>&1 || true
            fi
            
            # ç®€å•ç›‘æ§
            echo "ç£ç›˜ç©ºé—´:"
            df -h | grep "/var/lib/docker" | awk '{print $4 " available"}' || true

          done < images.txt

      - name: æ›´æ–° README Badge
        run: |
          # è·å–å½“å‰ UTC+8 æ—¶é—´
          DATE=$(TZ='Asia/Shanghai' date +'%Y--%m--%d %H:%M:%S')
          # URL Encode (space -> %20)
          ENC_DATE=${DATE// /%20}

          # æ„é€ æ–°çš„ badge é“¾æ¥
          NEW_BADGE="https://img.shields.io/badge/last%20sync-$ENC_DATE-green"

          # æ›¿æ¢ README ä¸­çš„ badge
          # åŒ¹é…æ¨¡å¼: ![Last Sync](https://img.shields.io/badge/.*)
          sed -i "s|!\[Last Sync\](.*)|![Last Sync]($NEW_BADGE)|g" README.md

          # æäº¤æ›´æ”¹
          if [[ -n $(git status -s) ]]; then
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git commit -m "docs: update last sync badge [skip ci]"
            git push
          else
             echo "æ²¡æœ‰å˜æ›´éœ€è¦æäº¤ã€‚"
          fi

      - name: å‘é€ Webhook é€šçŸ¥
        if: always()
        run: |
          if [ -z "$WEBHOOK_URL" ]; then
            echo "æœªé…ç½® WEBHOOK_URLï¼Œè·³è¿‡é€šçŸ¥ã€‚"
            exit 0
          fi

          JOB_STATUS="${{ job.status }}"
          REPO_NAME="${{ github.repository }}"
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          if [ "$JOB_STATUS" == "success" ]; then
             COLOR="info"
             TITLE="âœ… æ‰¹é‡åŒæ­¥æˆåŠŸ"
          else
             COLOR="warning"
             TITLE="âŒ æ‰¹é‡åŒæ­¥å¤±è´¥"
          fi

          # æ„é€ ç®€å• JSON (é€‚é…å¸¸è§çš„é’‰é’‰/é£ä¹¦/Discord/Slack)
          # è¿™é‡Œé‡‡ç”¨é€šç”¨ JSON ç»“æ„ï¼Œå¯è§†éœ€è¦è°ƒæ•´

          PAYLOAD=$(cat <<EOF
          {
            "msg_type": "text",
            "content": {
              "text": "$TITLE\nä»“åº“: $REPO_NAME\nçŠ¶æ€: $JOB_STATUS\né“¾æ¥: $RUN_URL"
            }
          }
          EOF
          )

          echo "å‘é€é€šçŸ¥..."
          curl -H "Content-Type: application/json" -d "$PAYLOAD" "$WEBHOOK_URL" || echo "å‘é€å¤±è´¥"
